=============================
            Magro
=============================
-----------------------------
        User's Manual
-----------------------------

:Author: Isaac Rivas
:Version: 1
:Copyright: This document has been placed in the public domain.


.. contents::

1 What is magro?
================

Magro is an open source template engine written in Python. It
is designed for writting very lean templates code.

It can be used for generating any kind of text output, but the
hierarchical nature of its syntax makes it specially useful for
creating html files.

2 Configuration
===============

2.1 Dependencies
----------------

Magro makes use of the PLY library for Python. PLY is an LR parser
generator and can be found at: http://www.dabeaz.com/ply/

2.2 Environment
----------------

The following values should be set for Magro to work:

``MAGRO_PATH``
    This environment variable is the list of directories that Magro
    will use to find the libraries imported by the templates.
    
    This value can be set programatically from Python code through
    the ``macro.env.path`` variable:

        >>> import magro.env as env
        >>> env.path.append( '/path/to/magro/libraries' )
        >>> env.path
        ['.', '/path/to/magro/libraries']
        
    By default, this variable includes the current invocation
    path (i.e. ``'.'``)

3 Invocation
============

3.1 The Magro Tool
------------------

You can use the ``magro\tool.py`` script to evaluate your magro template,
this script receives input from ``stdin`` and outputs to ``stdout`` by
default; but you can tell it to receive its input from a file and to write
its output to another file.
::

    python magro/tool.py -o target.html source_template

3.2 Python Library
------------------

To use Magro as a python library, import the ``magro.parser`` package:

    >>> import magro.parser as parser

Then call it's parse method to translate the template:

    >>> import magro.parser as parser
    >>> parser.parse("'hello ' target \n", { 'target':'world' })
    hello world
    
Or you can compile it and reuse it multiple times:

    >>> import magro.parser as parser
    >>> template = parser.compile("'hello ' target \n")
    >>> template.eval({ 'target':'world' })
    hello world
    >>> template.eval({ 'target':'again' })
    hello again

4 Language Guide
================

Magro is a language with very few syntax elements and most of the
functionality will be determined by user defined macros and libraries.

An example script and its output is show below::

    import 'html5'
    
    html:
        body:
            div(id='d1'):
                'Some text'

Will generate the following output::

    <html><body><div id="d1">Some text</div><body></html>


4.1 Macros
----------

Macros are the basic unit of the Magro language, they can be
defined and called with a set of parameters and an optional body.
The result of the call will be appended to the output text. If a
call to a macro cannot be resolved, it will simply be ignored.

The name of any macro can be any succession of alphabetic or
numeric characters, underscores ('_'), dots ('.') or hyphens ('-')

4.1.1 Invocation of macros
~~~~~~~~~~~~~~~~~~~~~~~~~~

A macro can be called without parameters::

    this_is_a_macro_call
    
With parameters::

    macro( 'parameter' )
    
With a body parameter, indented from the parent call::

    macro:
        'body'
        
    anothermacro( 'parameter' ):
        body:
            anothercall
        'more body'

In the last example, the macro call ``anothercall`` is the body
of the call to the ``body`` macro. The body of the ``anothermacro``
call is composed of the call to ``body`` and the ``'more body'`` string.

In magro, indentation is important as it is used to determine what
expressions belong to the body of each call. Note that when a body
is used in a macro call, a colon ``':'`` must be written to make it more
explicit that this macro call has a body.

**Parameters**

The list of parameters is optional for the call and has the
following syntax::

    ( parameter_name = parametervalue, param2 = value2, paramN = valueN )
    
The parameter name is optional and the parameter value can any sequence
of expressions separated by spaces, either of strings, of macro calls,
cycles or any combination of them; for example::

    div( id='head' index, class='container' ):
        'body of the div'

In the example above, the parameter ``ìd`` will be assigned a value formed by 
the concatenation of ``'head'`` and the result of the call to ``index``.

**Evaluation order**

A function call will try to determine its value in the following order:

    1. Look up the value in the context the user passes to the parser at invocation.
       a) Look up a renderer for the type of the found object.
       b) Use the string representation of the found object.
    2. Look up the value as a parameter passed to the called macro.
    3. Look up a macro definition of the same name.
    4. Use an empty string as result.

4.1.2 Definition of macros
~~~~~~~~~~~~~~~~~~~~~~~~~~

A macro can be defined using the following syntax::

    def macroname( parameters ):
        code_of_the_macro
        
The ``code_of_the_macro`` is a sequence of calls of the form described in the
previous section, that will be invoqued when the defined macro is called.

The list of parameters is optional and can be used to define default values to
any parameter that the used might ommit from the macro call. At the moment of
invocation, the caller might decide not to use all of the declared parameter names
or to pass any parameter that is not declared in the macro definition. For example::

    some_macro( some_random_param='some_value' )

    def some_macro( id, class='default' ):
        'Macro value'

In this case, ``id``will have no value, ``class`` will have the string ``'default'`` as
value, and some_random_param will be passed to the call even if it is not used by the
macro definition.

A call to a parameter is actually the same as a macro call, and the rules for determining
its value described in the previous section apply to it.

4.1.3 Implicit values
~~~~~~~~~~~~~~~~~~~~~

There are a number of symbols that can be used on macro definitions without being explicitly
declared or given values by its caller. All these values have the following form::

    $name_of_variable
    
If the implicit variable does not exist, it will be ignored.

All macro declarations can use the following implicit values:

    ``$``
        Represents the body used in the macro call. If no body was used in the call, it is an empty string.

    ``$all``
        Returns an array of all the parameters used during the call in the order they were written.

    ``$undeclared``
        Returns an array with all the parameters used at the macro call, but only if they are not declared
        in the macro definition.

    ``$1, $2, ...``
        Besides the actual names of the parameters (in case their names were used,) each parameter can be
        accessed by its position in the macro call, where ``$1`` is the first parameter, ``$2`` the second
        and so.
        
More implicit values will be explained in the context they are available.

4.1.4 Type renderers
~~~~~~~~~~~~~~~~~~~~

Special macro declarations can be defined to be invoqued when an object of certain type is encountered.
This kind of macros can be defined using the following syntax::

    @name_of_the_type( parameters ):
        code_of_the_macro
        
The engine will try to match the object type hierarchy with the name used in the macro definition. If no
definition is found, the string representation of the object will be used.

The ``code_of_the_macro`` section and parameters definition follows the same rules described in section 4.1.2.
Except for the fact of being invoqued when a type match is found, this kind of macros behave just like normal
macros.

**Implicit values**

There is an additional implicit value that will be available in this kind of macros:

    ``$object``
        Contains the reference to the object that triggered the macro invocation.

4.2 Strings
-----------

Strings can be used inside macro calls or as part of parameter value definition. They can be written
in three diferent forms:

    1. **Normal strings**, written between single (') or double quotes (") with no new line inside them::

        'This is a normal string'
        "This is a normal string too"
    
    2. **Line strings**, beginning with a single or double quote and ending with a new line::

        'This is a line string.
        'Line strings will have a new line
        'appended at the end.
        "This is another line string.

    3. **Long strings**, written between a pair of three single quotes (''') or double quotes (""") can contain new lines inside them::
       
        '''This is a
        long string
        of many
        lines'''
        
        """This is another
        example of a
        long string"""
        
All kinds of strings can contain escape characters using the same set as Python strings. Please refer to the Python
documentation for more details on this.

4.3 Cycles
----------

As many template engines, Magro has a special syntax to support loops over a collection of
items, a set of parameters or an iterator. The syntax for a loop is as follows::

    [ expressions_evaluated_for_each_value ](lists_of_values)

Each part has its own rules described below.

4.3.1 The list of values
~~~~~~~~~~~~~~~~~~~~~~~~

Syntax example::

    ( optional_key = value, key2 = value2, another_value )

This is a list of values separated by commas (,) very similar to the parameters passed to a
macro call, but with the following exceptions:



4.3.2 The expressions to evaluate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO.
    
**Implicit values**
 
    ``$key``
        TODO.

    ``$value``
        TODO.

    ``$index``
        TODO.

4.4 Groups
----------

TODO.

4.5 Import clause
-----------------

TODO.


4.6 Python expressions
----------------------

TODO.

4.7 The Context object
----------------------

TODO.

4.8 Comments
------------

Commentaries to the code can be written beginning the comment with a ``'#'`` character. All text
following this character up to the next new line character will be ignored.
